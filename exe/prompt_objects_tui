#!/usr/bin/env ruby
# frozen_string_literal: true

# Add lib to load path
$LOAD_PATH.unshift File.expand_path("../lib", __dir__)

require "bundler/setup"
require "prompt_objects"
require "prompt_objects/cli"
require "prompt_objects/ui/app"

# Parse command line arguments
def parse_args
  options = PromptObjects::CLI.parse(ARGV)

  # Handle env subcommand
  if options[:command] == :env
    PromptObjects::CLI::EnvCommand.new.run(options[:env_args] || [])
    exit 0
  end

  # Handle help
  if options[:command] == :help
    print_help
    exit 0
  end

  options
end

def print_help
  puts <<~HELP
    Usage: prompt_objects_tui [options] [env_name]

    Run the TUI interface for PromptObjects.

    Arguments:
      env_name         Environment to open (or uses default)

    Options:
      --env, -e <name> Open specific environment
      --dev            Use development environment (isolated)
      --sandbox, -s    Run in sandbox mode (legacy)
      --help, -h       Show this help message

    Environment Commands:
      prompt_objects_tui env list       List all environments
      prompt_objects_tui env create     Create new environment
      prompt_objects_tui env info       Show environment details

    Keyboard Shortcuts:
      q, Ctrl+C     Quit
      ?             Toggle help
      m             Toggle message log
      i             Inspect selected PO
      e             Edit PO capabilities
      <-/->         Switch between POs
      Enter         Send message / Activate PO

    First Run:
      On first run with no environments, you'll be prompted to create one.
  HELP
end

def main
  args = parse_args
  manager = PromptObjects::Env::Manager.new
  manager.setup!

  # Determine how to run based on args
  if args[:dev_mode] || ENV["PROMPT_OBJECTS_DEV"]
    # Development mode - skip picker, use dev environment
    PromptObjects::UI::App.run(manager: manager, dev_mode: true)
  elsif args[:env_name]
    # Specific environment requested
    unless manager.environment_exists?(args[:env_name])
      puts "Environment '#{args[:env_name]}' not found."
      puts
      puts "Available environments:"
      manager.list.each { |name| puts "  - #{name}" }
      exit 1
    end
    env_path = manager.environment_path(args[:env_name])
    PromptObjects::UI::App.run(env_path: env_path)
  elsif args[:legacy_args]&.any?
    # Legacy: treat argument as objects_dir or environment name
    arg = args[:legacy_args].first
    if manager.environment_exists?(arg)
      env_path = manager.environment_path(arg)
      PromptObjects::UI::App.run(env_path: env_path)
    elsif Dir.exist?(arg)
      # Legacy mode with objects_dir
      run_legacy_mode(arg, args)
    else
      puts "Not found: '#{arg}' (neither environment nor directory)"
      exit 1
    end
  else
    # Normal mode - let App handle picker/wizard flow
    PromptObjects::UI::App.run(manager: manager)
  end
end

def run_legacy_mode(objects_dir, args)
  primitives_dir = nil

  if args[:sandbox]
    require "fileutils"
    require "tmpdir"

    sandbox_dir = Dir.mktmpdir("prompt_objects_sandbox_")
    objects_dir_sandbox = File.join(sandbox_dir, "objects")
    primitives_dir = File.join(sandbox_dir, "primitives")

    FileUtils.mkdir_p(objects_dir_sandbox)
    FileUtils.mkdir_p(primitives_dir)

    original_dir = File.expand_path(objects_dir)
    if Dir.exist?(original_dir)
      Dir.glob(File.join(original_dir, "*.md")).each do |src|
        FileUtils.cp(src, objects_dir_sandbox)
      end
    end

    puts "Sandbox initialized at: #{sandbox_dir}"
    objects_dir = objects_dir_sandbox

    at_exit do
      FileUtils.rm_rf(sandbox_dir) if Dir.exist?(sandbox_dir)
      puts "Sandbox cleaned up"
    end
  end

  PromptObjects::UI::App.run(
    objects_dir: objects_dir,
    primitives_dir: primitives_dir
  )
end

main

#!/usr/bin/env ruby
# frozen_string_literal: true

# Add lib to load path
$LOAD_PATH.unshift File.expand_path("../lib", __dir__)

require "bundler/setup"
require "prompt_objects"
require "fileutils"
require "tmpdir"

# Sandbox manages an isolated environment for testing
class Sandbox
  attr_reader :sandbox_dir, :objects_dir, :primitives_dir, :original_objects_dir

  def initialize(original_objects_dir)
    @original_objects_dir = File.expand_path(original_objects_dir)
    @sandbox_dir = Dir.mktmpdir("prompt_objects_sandbox_")
    @objects_dir = File.join(@sandbox_dir, "objects")
    @primitives_dir = File.join(@sandbox_dir, "primitives")

    setup
  end

  def setup
    FileUtils.mkdir_p(@objects_dir)
    FileUtils.mkdir_p(@primitives_dir)

    # Copy existing objects to sandbox
    if Dir.exist?(@original_objects_dir)
      Dir.glob(File.join(@original_objects_dir, "*.md")).each do |src|
        FileUtils.cp(src, @objects_dir)
      end
    end

    puts "Sandbox initialized at: #{@sandbox_dir}"
    puts "   Objects copied: #{Dir.glob(File.join(@objects_dir, '*.md')).count}"
  end

  def cleanup(keep_changes: false)
    if keep_changes
      copy_back_changes
    end
    FileUtils.rm_rf(@sandbox_dir)
    puts "Sandbox cleaned up"
  end

  def copy_back_changes
    # Find new/modified objects
    new_objects = Dir.glob(File.join(@objects_dir, "*.md")).select do |sandbox_file|
      original = File.join(@original_objects_dir, File.basename(sandbox_file))
      !File.exist?(original) || File.read(sandbox_file) != File.read(original)
    end

    # Find new primitives
    new_primitives = Dir.glob(File.join(@primitives_dir, "*.rb"))

    return if new_objects.empty? && new_primitives.empty?

    puts "\nChanges to copy back:"
    new_objects.each { |f| puts "   + objects/#{File.basename(f)}" }
    new_primitives.each { |f| puts "   + primitives/#{File.basename(f)}" }

    print "\nCopy these to main project? (y/n): "
    answer = $stdin.gets&.chomp&.downcase
    return unless answer == "y"

    new_objects.each do |f|
      FileUtils.cp(f, @original_objects_dir)
    end

    if new_primitives.any?
      target_primitives = File.join(File.dirname(@original_objects_dir), "primitives")
      FileUtils.mkdir_p(target_primitives)
      new_primitives.each do |f|
        FileUtils.cp(f, target_primitives)
      end
    end

    puts "Changes copied to main project"
  end

  def show_new_files
    new_objects = Dir.glob(File.join(@objects_dir, "*.md")).reject do |sandbox_file|
      original = File.join(@original_objects_dir, File.basename(sandbox_file))
      File.exist?(original) && File.read(sandbox_file) == File.read(original)
    end
    new_primitives = Dir.glob(File.join(@primitives_dir, "*.rb"))

    { objects: new_objects, primitives: new_primitives }
  end
end

# Simple REPL for interacting with a Prompt Object
class REPL
  def initialize(prompt_object, env, sandbox: nil)
    @po = prompt_object
    @env = env
    @context = env.context
    @show_log = true  # Show message log by default
    @sandbox = sandbox
  end

  def run
    puts header
    if @sandbox
      puts "SANDBOX MODE - changes isolated from main project"
      puts
    end
    puts "Loaded: #{@po.name}"
    puts @po.description
    puts
    puts "Capabilities: #{format_capabilities}"
    puts "-" * 60
    puts "Commands: 'exit', 'history', 'log', 'log on/off', 'sandbox' (if in sandbox mode)"
    puts

    loop do
      print "You: "
      input = $stdin.gets&.chomp

      break if input.nil?
      next if input.empty?

      case input.downcase
      when "exit", "quit"
        handle_exit
        break
      when "history"
        show_history
        next
      when "log"
        show_message_log
        next
      when "log on"
        @show_log = true
        puts "Message log display: ON"
        next
      when "log off"
        @show_log = false
        puts "Message log display: OFF"
        next
      when "sandbox"
        show_sandbox_status
        next
      end

      # Clear log before each interaction to show only relevant messages
      log_start = @env.bus.log.length

      begin
        # Log the human message
        @env.bus.publish(from: "human", to: @po.name, message: input)

        @context.current_capability = @po.name
        response = @po.receive(input, context: @context)

        # Log the response back to human
        @env.bus.publish(from: @po.name, to: "human", message: response)

        # Show the message log for this interaction
        if @show_log
          puts
          show_interaction_log(log_start)
        end

        puts
        puts "#{@po.name}: #{response}"
        puts
      rescue StandardError => e
        puts "\nError: #{e.message}"
        puts e.backtrace.first(5).join("\n") if ENV["DEBUG"]
        puts
      end
    end
  end

  private

  def header
    <<~HEADER

      PromptObjects v0.1.0

    HEADER
  end

  def format_capabilities
    caps = @po.config["capabilities"] || []
    return "(none)" if caps.empty?

    caps.map do |cap_name|
      cap = @env.registry.get(cap_name)
      if cap.is_a?(PromptObjects::PromptObject)
        "#{cap_name} (PO)"
      elsif cap.is_a?(PromptObjects::Primitive)
        "#{cap_name}"
      else
        "#{cap_name} (?)"
      end
    end.join(", ")
  end

  def handle_exit
    puts "\nGoodbye!"
    return unless @sandbox

    new_files = @sandbox.show_new_files
    if new_files[:objects].any? || new_files[:primitives].any?
      puts "\nSession created files:"
      new_files[:objects].each { |f| puts "   - #{File.basename(f)}" }
      new_files[:primitives].each { |f| puts "   - #{File.basename(f)}" }
      @sandbox.cleanup(keep_changes: true)
    else
      puts "No new files created."
      @sandbox.cleanup(keep_changes: false)
    end
  end

  def show_sandbox_status
    unless @sandbox
      puts "Not in sandbox mode. Run with --sandbox to enable."
      return
    end

    puts "\nSandbox Status"
    puts "   Location: #{@sandbox.sandbox_dir}"
    new_files = @sandbox.show_new_files
    if new_files[:objects].any? || new_files[:primitives].any?
      puts "   New/modified files this session:"
      new_files[:objects].each { |f| puts "     + #{File.basename(f)}" }
      new_files[:primitives].each { |f| puts "     + #{File.basename(f)}" }
    else
      puts "   No new files created yet."
    end
    puts
  end

  def show_history
    puts "\n--- Conversation History ---"
    @po.history.each_with_index do |msg, i|
      role = msg[:role].to_s.capitalize
      content = msg[:content]&.slice(0, 100)
      content += "..." if msg[:content]&.length.to_i > 100
      puts "#{i + 1}. [#{role}] #{content}"
    end
    puts "----------------------------\n\n"
  end

  def show_message_log
    puts "\n--- Full Message Log ---"
    puts @env.bus.format_log(50)
    puts "------------------------\n\n"
  end

  def show_interaction_log(start_index)
    entries = @env.bus.log[start_index..]
    return if entries.nil? || entries.empty?

    puts "--- Message Log ---"
    entries.each do |entry|
      time = entry[:timestamp].strftime("%H:%M:%S")
      from = entry[:from]
      to = entry[:to]
      msg = entry[:message]

      line = "#{time}  #{from} -> #{to}: #{msg}"
      line = line[0, 70] + "..." if line.length > 73
      puts line
    end
    puts "-------------------"
  end
end

# === CLI Command Handling ===

def print_main_help
  puts <<~HELP
    Usage: prompt_objects <command> [options]

    Commands:
      repl [name] [objects_dir]   Start interactive REPL with a prompt object
      serve                        Run environment as a server (MCP, API, etc.)
      help                         Show this help message

    Run 'prompt_objects <command> --help' for command-specific help.

    Examples:
      prompt_objects repl greeter              # Start REPL with 'greeter' PO
      prompt_objects serve --mcp my-assistant  # Run as MCP server
  HELP
end

def print_repl_help
  puts <<~HELP
    Usage: prompt_objects repl [options] [name] [objects_dir]

    Arguments:
      name         Prompt object to load (default: greeter)
      objects_dir  Directory containing .md files (default: objects)

    Options:
      --sandbox, -s   Run in sandbox mode (isolates changes from main project)
      --help, -h      Show this help message

    Sandbox Mode:
      When running with --sandbox, all new capabilities and prompt objects
      created during the session are stored in a temporary directory.
      On exit, you'll be prompted to copy changes back to the main project.
  HELP
end

def print_serve_help
  puts <<~HELP
    Usage: prompt_objects serve [options] <environment>

    Run an environment as a server, exposing it through different interfaces.

    Arguments:
      environment  Environment name or path to environment directory

    Options:
      --web            Run as web server with React UI (default)
      --mcp            Run as MCP server (stdio transport, for Claude Desktop/Cursor)
      --port PORT      Port for web server (default: 3000)
      --host HOST      Host for web server (default: localhost)
      --open           Open browser automatically
      --help, -h       Show this help message

    Examples:
      prompt_objects serve my-assistant              # Web UI (default)
      prompt_objects serve my-assistant --port 4000  # Custom port
      prompt_objects serve --mcp my-assistant        # MCP server mode
      prompt_objects serve ./my-environment          # Serve from path

    Claude Desktop Configuration (MCP mode):
      Add to claude_desktop_config.json:
      {
        "mcpServers": {
          "my-assistant": {
            "command": "prompt_objects",
            "args": ["serve", "--mcp", "my-assistant"]
          }
        }
      }
  HELP
end

def run_repl(args)
  options = {
    name: "greeter",
    objects_dir: "objects",
    sandbox: false
  }

  positional = []
  args.each do |arg|
    case arg
    when "--sandbox", "-s"
      options[:sandbox] = true
    when "--help", "-h"
      print_repl_help
      exit 0
    else
      positional << arg
    end
  end

  options[:name] = positional[0] if positional[0]
  options[:objects_dir] = positional[1] if positional[1]

  sandbox = nil
  primitives_dir = nil

  if options[:sandbox]
    sandbox = Sandbox.new(options[:objects_dir])
    objects_dir = sandbox.objects_dir
    primitives_dir = sandbox.primitives_dir
  else
    objects_dir = options[:objects_dir]
  end

  env = PromptObjects::Runtime.new(objects_dir: objects_dir, primitives_dir: primitives_dir)

  begin
    po = env.load_by_name(options[:name])
    env.load_dependencies(po)
  rescue PromptObjects::Error => e
    puts "Error loading '#{options[:name]}': #{e.message}"
    puts "\nAvailable objects in '#{objects_dir}/':"
    Dir.glob(File.join(objects_dir, "*.md")).each do |path|
      puts "  - #{File.basename(path, '.md')}"
    end
    sandbox&.cleanup(keep_changes: false)
    exit 1
  end

  REPL.new(po, env, sandbox: sandbox).run
end

def run_serve(args)
  options = {
    web: false,
    mcp: false,
    port: 3000,
    host: "localhost",
    open: false,
    environment: nil
  }

  skip_next = false
  args.each_with_index do |arg, i|
    if skip_next
      skip_next = false
      next
    end

    case arg
    when "--web"
      options[:web] = true
    when "--mcp"
      options[:mcp] = true
    when "--port"
      options[:port] = args[i + 1].to_i
      skip_next = true
    when "--host"
      options[:host] = args[i + 1]
      skip_next = true
    when "--open", "-o"
      options[:open] = true
    when "--help", "-h"
      print_serve_help
      exit 0
    else
      # Assume it's the environment
      options[:environment] = arg unless arg.start_with?("-")
    end
  end

  unless options[:environment]
    puts "Error: environment name or path required"
    puts "Run 'prompt_objects serve --help' for usage"
    exit 1
  end

  # Default to web if no interface specified
  options[:web] = true unless options[:mcp]

  # Redirect stderr to a log file to avoid polluting MCP stdio
  if options[:mcp] && ENV["PROMPT_OBJECTS_LOG"]
    $stderr.reopen(ENV["PROMPT_OBJECTS_LOG"], "a")
    $stderr.sync = true
  end

  # Resolve environment
  env_path = resolve_environment(options[:environment])
  unless env_path
    $stderr.puts "Error: environment '#{options[:environment]}' not found"
    exit 1
  end

  # Load the runtime
  runtime = PromptObjects::Runtime.new(env_path: env_path)

  # Load all prompt objects
  load_all_objects(runtime, env_path)

  if options[:mcp]
    connector = PromptObjects::Connectors::MCP.new(runtime: runtime)
    connector.start
  elsif options[:web]
    require "prompt_objects/server"

    # Open browser if requested
    if options[:open]
      url = "http://#{options[:host]}:#{options[:port]}"
      open_browser(url)
    end

    PromptObjects::Server.start(
      runtime: runtime,
      host: options[:host],
      port: options[:port],
      env_path: env_path
    )
  end
end

def open_browser(url)
  case RUBY_PLATFORM
  when /darwin/
    system("open", url)
  when /linux/
    system("xdg-open", url)
  when /mswin|mingw/
    system("start", url)
  end
end

def resolve_environment(name_or_path)
  # Check if it's already a path
  if File.directory?(name_or_path)
    manifest_path = File.join(name_or_path, "manifest.yml")
    return name_or_path if File.exist?(manifest_path)
  end

  # Check in standard locations
  locations = [
    File.join(Dir.home, ".prompt_objects", "environments", name_or_path),
    File.join(".", name_or_path)
  ]

  locations.each do |path|
    manifest_path = File.join(path, "manifest.yml")
    return path if File.exist?(manifest_path)
  end

  nil
end

def load_all_objects(runtime, env_path)
  objects_dir = File.join(env_path, "objects")
  return unless Dir.exist?(objects_dir)

  Dir.glob(File.join(objects_dir, "*.md")).each do |path|
    runtime.load_prompt_object(path)
  rescue StandardError => e
    $stderr.puts "Warning: Failed to load #{path}: #{e.message}"
  end

  runtime.registry.prompt_objects.each do |po|
    runtime.load_dependencies(po)
  end
end

# === Main Entry Point ===

def main
  if ARGV.empty?
    print_main_help
    exit 0
  end

  command = ARGV[0]
  args = ARGV[1..]

  case command
  when "repl"
    run_repl(args)
  when "serve"
    run_serve(args)
  when "help", "--help", "-h"
    print_main_help
  else
    # Legacy behavior: treat as repl with name argument
    run_repl(ARGV)
  end
end

main

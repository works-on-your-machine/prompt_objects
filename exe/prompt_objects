#!/usr/bin/env ruby
# frozen_string_literal: true

# Add lib to load path for development (harmless when gem is installed)
$LOAD_PATH.unshift File.expand_path("../lib", __dir__)

# Note: Do NOT require "bundler/setup" here - it would conflict with
# the user's project Gemfile if they run this from within a Rails app, etc.
require "prompt_objects"
require "prompt_objects/cli"
require "fileutils"
require "tmpdir"

# Sandbox manages an isolated environment for testing
class Sandbox
  attr_reader :sandbox_dir, :objects_dir, :primitives_dir, :original_objects_dir

  def initialize(original_objects_dir)
    @original_objects_dir = File.expand_path(original_objects_dir)
    @sandbox_dir = Dir.mktmpdir("prompt_objects_sandbox_")
    @objects_dir = File.join(@sandbox_dir, "objects")
    @primitives_dir = File.join(@sandbox_dir, "primitives")

    setup
  end

  def setup
    FileUtils.mkdir_p(@objects_dir)
    FileUtils.mkdir_p(@primitives_dir)

    # Copy existing objects to sandbox
    if Dir.exist?(@original_objects_dir)
      Dir.glob(File.join(@original_objects_dir, "*.md")).each do |src|
        FileUtils.cp(src, @objects_dir)
      end
    end

    puts "Sandbox initialized at: #{@sandbox_dir}"
    puts "   Objects copied: #{Dir.glob(File.join(@objects_dir, '*.md')).count}"
  end

  def cleanup(keep_changes: false)
    if keep_changes
      copy_back_changes
    end
    FileUtils.rm_rf(@sandbox_dir)
    puts "Sandbox cleaned up"
  end

  def copy_back_changes
    # Find new/modified objects
    new_objects = Dir.glob(File.join(@objects_dir, "*.md")).select do |sandbox_file|
      original = File.join(@original_objects_dir, File.basename(sandbox_file))
      !File.exist?(original) || File.read(sandbox_file) != File.read(original)
    end

    # Find new primitives
    new_primitives = Dir.glob(File.join(@primitives_dir, "*.rb"))

    return if new_objects.empty? && new_primitives.empty?

    puts "\nChanges to copy back:"
    new_objects.each { |f| puts "   + objects/#{File.basename(f)}" }
    new_primitives.each { |f| puts "   + primitives/#{File.basename(f)}" }

    print "\nCopy these to main project? (y/n): "
    answer = $stdin.gets&.chomp&.downcase
    return unless answer == "y"

    new_objects.each do |f|
      FileUtils.cp(f, @original_objects_dir)
    end

    if new_primitives.any?
      target_primitives = File.join(File.dirname(@original_objects_dir), "primitives")
      FileUtils.mkdir_p(target_primitives)
      new_primitives.each do |f|
        FileUtils.cp(f, target_primitives)
      end
    end

    puts "Changes copied to main project"
  end

  def show_new_files
    new_objects = Dir.glob(File.join(@objects_dir, "*.md")).reject do |sandbox_file|
      original = File.join(@original_objects_dir, File.basename(sandbox_file))
      File.exist?(original) && File.read(sandbox_file) == File.read(original)
    end
    new_primitives = Dir.glob(File.join(@primitives_dir, "*.rb"))

    { objects: new_objects, primitives: new_primitives }
  end
end

# Simple REPL for interacting with a Prompt Object
class REPL
  def initialize(prompt_object, env, sandbox: nil)
    @po = prompt_object
    @env = env
    @context = env.context
    @show_log = true  # Show message log by default
    @sandbox = sandbox
  end

  def run
    puts header
    if @sandbox
      puts "SANDBOX MODE - changes isolated from main project"
      puts
    end
    puts "Loaded: #{@po.name}"
    puts @po.description
    puts
    puts "Capabilities: #{format_capabilities}"
    puts "-" * 60
    puts "Commands: 'exit', 'history', 'log', 'log on/off', 'sandbox' (if in sandbox mode)"
    puts

    loop do
      print "You: "
      input = $stdin.gets&.chomp

      break if input.nil?
      next if input.empty?

      case input.downcase
      when "exit", "quit"
        handle_exit
        break
      when "history"
        show_history
        next
      when "log"
        show_message_log
        next
      when "log on"
        @show_log = true
        puts "Message log display: ON"
        next
      when "log off"
        @show_log = false
        puts "Message log display: OFF"
        next
      when "sandbox"
        show_sandbox_status
        next
      end

      # Clear log before each interaction to show only relevant messages
      log_start = @env.bus.log.length

      begin
        # Log the human message
        @env.bus.publish(from: "human", to: @po.name, message: input)

        @context.current_capability = @po.name
        response = @po.receive(input, context: @context)

        # Log the response back to human
        @env.bus.publish(from: @po.name, to: "human", message: response)

        # Show the message log for this interaction
        if @show_log
          puts
          show_interaction_log(log_start)
        end

        puts
        puts "#{@po.name}: #{response}"
        puts
      rescue StandardError => e
        puts "\nError: #{e.message}"
        puts e.backtrace.first(5).join("\n") if ENV["DEBUG"]
        puts
      end
    end
  end

  private

  def header
    <<~HEADER

      PromptObjects v0.1.0

    HEADER
  end

  def format_capabilities
    caps = @po.config["capabilities"] || []
    return "(none)" if caps.empty?

    caps.map do |cap_name|
      cap = @env.registry.get(cap_name)
      if cap.is_a?(PromptObjects::PromptObject)
        "#{cap_name} (PO)"
      elsif cap.is_a?(PromptObjects::Primitive)
        "#{cap_name}"
      else
        "#{cap_name} (?)"
      end
    end.join(", ")
  end

  def handle_exit
    puts "\nGoodbye!"
    return unless @sandbox

    new_files = @sandbox.show_new_files
    if new_files[:objects].any? || new_files[:primitives].any?
      puts "\nSession created files:"
      new_files[:objects].each { |f| puts "   - #{File.basename(f)}" }
      new_files[:primitives].each { |f| puts "   - #{File.basename(f)}" }
      @sandbox.cleanup(keep_changes: true)
    else
      puts "No new files created."
      @sandbox.cleanup(keep_changes: false)
    end
  end

  def show_sandbox_status
    unless @sandbox
      puts "Not in sandbox mode. Run with --sandbox to enable."
      return
    end

    puts "\nSandbox Status"
    puts "   Location: #{@sandbox.sandbox_dir}"
    new_files = @sandbox.show_new_files
    if new_files[:objects].any? || new_files[:primitives].any?
      puts "   New/modified files this session:"
      new_files[:objects].each { |f| puts "     + #{File.basename(f)}" }
      new_files[:primitives].each { |f| puts "     + #{File.basename(f)}" }
    else
      puts "   No new files created yet."
    end
    puts
  end

  def show_history
    puts "\n--- Conversation History ---"
    @po.history.each_with_index do |msg, i|
      role = msg[:role].to_s.capitalize
      content = msg[:content]&.slice(0, 100)
      content += "..." if msg[:content]&.length.to_i > 100
      puts "#{i + 1}. [#{role}] #{content}"
    end
    puts "----------------------------\n\n"
  end

  def show_message_log
    puts "\n--- Full Message Log ---"
    puts @env.bus.format_log(50)
    puts "------------------------\n\n"
  end

  def show_interaction_log(start_index)
    entries = @env.bus.log[start_index..]
    return if entries.nil? || entries.empty?

    puts "--- Message Log ---"
    entries.each do |entry|
      time = entry[:timestamp].strftime("%H:%M:%S")
      from = entry[:from]
      to = entry[:to]
      msg = entry[:summary]

      line = "#{time}  #{from} -> #{to}: #{msg}"
      line = line[0, 70] + "..." if line.length > 73
      puts line
    end
    puts "-------------------"
  end
end

# === CLI Command Handling ===

def print_main_help
  puts <<~HELP
    Usage: prompt_objects <command> [options]

    Commands:
      env                          Manage environments (create, list, export, etc.)
      serve <env>                  Run environment as a web server
      message <env> <po> "text"    Send a message to a PO and print the response
      events <env> [--session ID]  Show recent events from the message bus
      repl [name] [objects_dir]    Start interactive REPL with a prompt object
      help                         Show this help message

    Run 'prompt_objects <command> --help' for command-specific help.

    Examples:
      prompt_objects env list                     # List all environments
      prompt_objects env create demo --template demo  # Create from template
      prompt_objects serve my-env                 # Start web UI
      prompt_objects serve my-env --open          # Start and open browser
      prompt_objects message my-env solver "Hello"     # Send a message
      prompt_objects message my-env solver "Hello" --json  # JSON output
  HELP
end

def print_repl_help
  puts <<~HELP
    Usage: prompt_objects repl [options] [name] [objects_dir]

    Arguments:
      name         Prompt object to load (default: greeter)
      objects_dir  Directory containing .md files (default: objects)

    Options:
      --sandbox, -s   Run in sandbox mode (isolates changes from main project)
      --help, -h      Show this help message

    Sandbox Mode:
      When running with --sandbox, all new capabilities and prompt objects
      created during the session are stored in a temporary directory.
      On exit, you'll be prompted to copy changes back to the main project.
  HELP
end

def print_serve_help
  puts <<~HELP
    Usage: prompt_objects serve [options] <environment>

    Run an environment as a server, exposing it through different interfaces.

    Arguments:
      environment  Environment name or path to environment directory

    Options:
      --web            Run as web server with React UI (default)
      --mcp            Run as MCP server (stdio transport, for Claude Desktop/Cursor)
      --port PORT      Port for web server (default: 3000)
      --host HOST      Host for web server (default: localhost)
      --open           Open browser automatically
      --help, -h       Show this help message

    Examples:
      prompt_objects serve my-assistant              # Web UI (default)
      prompt_objects serve my-assistant --port 4000  # Custom port
      prompt_objects serve --mcp my-assistant        # MCP server mode
      prompt_objects serve ./my-environment          # Serve from path

    Claude Desktop Configuration (MCP mode):
      Add to claude_desktop_config.json:
      {
        "mcpServers": {
          "my-assistant": {
            "command": "prompt_objects",
            "args": ["serve", "--mcp", "my-assistant"]
          }
        }
      }
  HELP
end

def run_repl(args)
  options = {
    name: "greeter",
    objects_dir: "objects",
    sandbox: false
  }

  positional = []
  args.each do |arg|
    case arg
    when "--sandbox", "-s"
      options[:sandbox] = true
    when "--help", "-h"
      print_repl_help
      exit 0
    else
      positional << arg
    end
  end

  options[:name] = positional[0] if positional[0]
  options[:objects_dir] = positional[1] if positional[1]

  sandbox = nil
  primitives_dir = nil

  if options[:sandbox]
    sandbox = Sandbox.new(options[:objects_dir])
    objects_dir = sandbox.objects_dir
    primitives_dir = sandbox.primitives_dir
  else
    objects_dir = options[:objects_dir]
  end

  env = PromptObjects::Runtime.new(objects_dir: objects_dir, primitives_dir: primitives_dir)

  begin
    po = env.load_by_name(options[:name])
    env.load_dependencies(po)
  rescue PromptObjects::Error => e
    puts "Error loading '#{options[:name]}': #{e.message}"
    puts "\nAvailable objects in '#{objects_dir}/':"
    Dir.glob(File.join(objects_dir, "*.md")).each do |path|
      puts "  - #{File.basename(path, '.md')}"
    end
    sandbox&.cleanup(keep_changes: false)
    exit 1
  end

  REPL.new(po, env, sandbox: sandbox).run
end

def run_serve(args)
  options = {
    web: false,
    mcp: false,
    port: 3000,
    host: "localhost",
    open: false,
    environment: nil
  }

  skip_next = false
  args.each_with_index do |arg, i|
    if skip_next
      skip_next = false
      next
    end

    case arg
    when "--web"
      options[:web] = true
    when "--mcp"
      options[:mcp] = true
    when "--port"
      options[:port] = args[i + 1].to_i
      skip_next = true
    when "--host"
      options[:host] = args[i + 1]
      skip_next = true
    when "--open", "-o"
      options[:open] = true
    when "--help", "-h"
      print_serve_help
      exit 0
    else
      # Assume it's the environment
      options[:environment] = arg unless arg.start_with?("-")
    end
  end

  unless options[:environment]
    puts "Error: environment name or path required"
    puts "Run 'prompt_objects serve --help' for usage"
    exit 1
  end

  # Default to web if no interface specified
  options[:web] = true unless options[:mcp]

  # Redirect stderr to a log file to avoid polluting MCP stdio
  if options[:mcp] && ENV["PROMPT_OBJECTS_LOG"]
    $stderr.reopen(ENV["PROMPT_OBJECTS_LOG"], "a")
    $stderr.sync = true
  end

  # Resolve environment
  env_path = resolve_environment(options[:environment])
  unless env_path
    $stderr.puts "Error: environment '#{options[:environment]}' not found"
    exit 1
  end

  # Load the runtime
  runtime = PromptObjects::Runtime.new(env_path: env_path)

  # Load all prompt objects
  load_all_objects(runtime, env_path)

  if options[:mcp]
    connector = PromptObjects::Connectors::MCP.new(runtime: runtime)
    connector.start
  elsif options[:web]
    require "prompt_objects/server"

    # Rebuild frontend to ensure built assets match source
    rebuild_frontend

    # Open browser if requested
    if options[:open]
      url = "http://#{options[:host]}:#{options[:port]}"
      open_browser(url)
    end

    PromptObjects::Server.start(
      runtime: runtime,
      host: options[:host],
      port: options[:port],
      env_path: env_path
    )
  end
end

def rebuild_frontend
  # Find the frontend directory relative to this executable
  gem_root = File.expand_path("../..", __FILE__)
  frontend_dir = File.join(gem_root, "frontend")

  unless Dir.exist?(frontend_dir)
    # No frontend source (e.g., installed as gem without source) â€” skip
    return
  end

  node_modules = File.join(frontend_dir, "node_modules")
  unless Dir.exist?(node_modules)
    puts "Frontend dependencies not installed. Run: cd frontend && npm install"
    return
  end

  print "Building frontend... "
  result = system("npm run build --prefix #{frontend_dir}", out: File::NULL, err: File::NULL)
  if result
    puts "done"
  else
    puts "failed (serving stale assets)"
  end
end

def open_browser(url)
  case RUBY_PLATFORM
  when /darwin/
    system("open", url)
  when /linux/
    system("xdg-open", url)
  when /mswin|mingw/
    system("start", url)
  end
end

def resolve_environment(name_or_path)
  # Check if it's already a path
  if File.directory?(name_or_path)
    manifest_path = File.join(name_or_path, "manifest.yml")
    return name_or_path if File.exist?(manifest_path)
  end

  # Check in standard locations
  locations = [
    File.join(Dir.home, ".prompt_objects", "environments", name_or_path),
    File.join(".", name_or_path)
  ]

  locations.each do |path|
    manifest_path = File.join(path, "manifest.yml")
    return path if File.exist?(manifest_path)
  end

  nil
end

def load_all_objects(runtime, env_path)
  objects_dir = File.join(env_path, "objects")
  return unless Dir.exist?(objects_dir)

  Dir.glob(File.join(objects_dir, "*.md")).each do |path|
    runtime.load_prompt_object(path)
  rescue StandardError => e
    $stderr.puts "Warning: Failed to load #{path}: #{e.message}"
  end

  runtime.registry.prompt_objects.each do |po|
    runtime.load_dependencies(po)
  end
end

def print_message_help
  puts <<~HELP
    Usage: prompt_objects message [options] <environment> <po_name> "message"

    Send a message to a prompt object and print the response.

    Arguments:
      environment  Environment name or path
      po_name      Name of the prompt object to message
      message      The message to send (quoted string)

    Options:
      --json           Output response as JSON
      --events         Also print the event log for this interaction
      --new-thread     Start a new thread for this message
      --session ID     Use a specific session ID
      --help, -h       Show this help

    If a server is running for the environment, the message is sent via
    HTTP to the running server (and streams to the web UI in real time).
    Otherwise, a standalone runtime is started for the request.

    Examples:
      prompt_objects message my-env solver "What patterns do you see?"
      prompt_objects message my-env solver "Solve task 1" --json
      prompt_objects message my-env solver "Try again" --new-thread
  HELP
end

def run_message(args)
  options = {
    json: false,
    events: false,
    new_thread: false,
    session_id: nil
  }

  positional = []
  skip_next = false

  args.each_with_index do |arg, i|
    if skip_next
      skip_next = false
      next
    end

    case arg
    when "--json"
      options[:json] = true
    when "--events"
      options[:events] = true
    when "--new-thread"
      options[:new_thread] = true
    when "--session"
      options[:session_id] = args[i + 1]
      skip_next = true
    when "--help", "-h"
      print_message_help
      exit 0
    else
      positional << arg
    end
  end

  env_name = positional[0]
  po_name = positional[1]
  message_text = positional[2]

  unless env_name && po_name && message_text
    puts "Error: environment, po_name, and message are required"
    puts "Run 'prompt_objects message --help' for usage"
    exit 1
  end

  # Resolve environment
  env_path = resolve_environment(env_name)
  unless env_path
    $stderr.puts "Error: environment '#{env_name}' not found"
    exit 1
  end

  # Check for running server
  require "prompt_objects/server"
  server_info = PromptObjects::Server.read_server_file(env_path)

  if server_info
    # Send via HTTP to running server
    send_message_via_http(server_info, po_name, message_text, options)
  else
    # Standalone mode
    send_message_standalone(env_path, po_name, message_text, options)
  end
end

def send_message_via_http(server_info, po_name, message_text, options)
  require "net/http"
  require "uri"

  uri = URI("http://#{server_info[:host]}:#{server_info[:port]}/api/prompt_objects/#{po_name}/message")

  body = { message: message_text }
  body[:new_thread] = true if options[:new_thread]
  body[:session_id] = options[:session_id] if options[:session_id]

  begin
    response = Net::HTTP.post(uri, body.to_json, "Content-Type" => "application/json")
    data = JSON.parse(response.body)

    if data["error"]
      $stderr.puts "Error: #{data['error']}"
      exit 1
    end

    if options[:json]
      puts JSON.pretty_generate(data)
    else
      puts data["response"]
    end

    if options[:events] && data["session_id"]
      events_uri = URI("http://#{server_info[:host]}:#{server_info[:port]}/api/events/session/#{data['session_id']}")
      events_response = Net::HTTP.get(events_uri)
      events_data = JSON.parse(events_response)

      if events_data["events"]&.any?
        $stderr.puts
        $stderr.puts "--- Events ---"
        events_data["events"].each do |e|
          $stderr.puts "#{e['timestamp']}  #{e['from']} -> #{e['to']}: #{e['summary']}"
        end
        $stderr.puts "--------------"
      end
    end
  rescue Errno::ECONNREFUSED
    $stderr.puts "Error: Server at #{server_info[:host]}:#{server_info[:port]} is not responding"
    $stderr.puts "The .server file may be stale. Try running standalone."
    exit 1
  end
end

def send_message_standalone(env_path, po_name, message_text, options)
  runtime = PromptObjects::Runtime.new(env_path: env_path)
  load_all_objects(runtime, env_path)

  po = runtime.registry.get(po_name)
  unless po.is_a?(PromptObjects::PromptObject)
    $stderr.puts "Error: prompt object '#{po_name}' not found"
    $stderr.puts "Available: #{runtime.loaded_objects.join(', ')}"
    exit 1
  end

  # Create new thread if requested
  po.new_thread if options[:new_thread]

  # Switch session if specified
  if options[:session_id]
    po.switch_session(options[:session_id])
  end

  session_id = po.session_id
  log_start = runtime.bus.log.length

  context = runtime.context
  context.current_capability = "human"

  # Log to bus
  runtime.bus.publish(from: "human", to: po.name, message: message_text, session_id: session_id)

  response = po.receive(message_text, context: context)

  # Log response to bus
  runtime.bus.publish(from: po.name, to: "human", message: response, session_id: session_id)

  if options[:json]
    data = {
      response: response,
      po_name: po.name,
      session_id: session_id,
      event_count: runtime.bus.log.length - log_start
    }
    puts JSON.pretty_generate(data)
  else
    puts response
  end

  if options[:events]
    entries = runtime.bus.log[log_start..]
    if entries&.any?
      $stderr.puts
      $stderr.puts "--- Events ---"
      entries.each do |entry|
        time = entry[:timestamp].strftime("%H:%M:%S")
        $stderr.puts "#{time}  #{entry[:from]} -> #{entry[:to]}: #{entry[:summary]}"
      end
      $stderr.puts "--------------"
    end
  end
end

def print_events_help
  puts <<~HELP
    Usage: prompt_objects events [options] <environment>

    Show recent events from the message bus.

    Arguments:
      environment  Environment name or path

    Options:
      --session ID     Show events for a specific session
      --count N        Number of events to show (default: 50)
      --json           Output as JSON
      --help, -h       Show this help

    Examples:
      prompt_objects events my-env
      prompt_objects events my-env --session abc-123
      prompt_objects events my-env --count 100 --json
  HELP
end

def run_events(args)
  options = { count: 50, session_id: nil, json: false }
  positional = []
  skip_next = false

  args.each_with_index do |arg, i|
    if skip_next
      skip_next = false
      next
    end

    case arg
    when "--session"
      options[:session_id] = args[i + 1]
      skip_next = true
    when "--count"
      options[:count] = args[i + 1].to_i
      skip_next = true
    when "--json"
      options[:json] = true
    when "--help", "-h"
      print_events_help
      exit 0
    else
      positional << arg
    end
  end

  env_name = positional[0]
  unless env_name
    puts "Error: environment name required"
    puts "Run 'prompt_objects events --help' for usage"
    exit 1
  end

  env_path = resolve_environment(env_name)
  unless env_path
    $stderr.puts "Error: environment '#{env_name}' not found"
    exit 1
  end

  # Check for running server
  require "prompt_objects/server"
  server_info = PromptObjects::Server.read_server_file(env_path)

  if server_info
    show_events_via_http(server_info, options)
  else
    show_events_standalone(env_path, options)
  end
end

def show_events_via_http(server_info, options)
  require "net/http"
  require "uri"

  if options[:session_id]
    uri = URI("http://#{server_info[:host]}:#{server_info[:port]}/api/events/session/#{options[:session_id]}")
  else
    uri = URI("http://#{server_info[:host]}:#{server_info[:port]}/api/events?count=#{options[:count]}")
  end

  response = Net::HTTP.get(uri)
  data = JSON.parse(response)

  if options[:json]
    puts JSON.pretty_generate(data)
  else
    print_events(data["events"] || [])
  end
rescue Errno::ECONNREFUSED
  $stderr.puts "Error: Server not responding"
  exit 1
end

def show_events_standalone(env_path, options)
  db_path = File.join(env_path, "sessions.db")
  unless File.exist?(db_path)
    puts "No event history (sessions.db not found)"
    exit 0
  end

  store = PromptObjects::Session::Store.new(db_path)

  events = if options[:session_id]
    store.get_events(session_id: options[:session_id])
  else
    store.get_recent_events(options[:count])
  end

  if options[:json]
    formatted = events.map do |e|
      {
        id: e[:id],
        from: e[:from],
        to: e[:to],
        summary: e[:summary],
        message: e[:message],
        timestamp: e[:timestamp]&.iso8601,
        session_id: e[:session_id]
      }
    end
    puts JSON.pretty_generate(formatted)
  else
    print_events(events)
  end

  store.close
end

def print_events(events)
  if events.empty?
    puts "No events found."
    return
  end

  events.each do |e|
    ts = e[:timestamp] || e["timestamp"]
    ts = ts.is_a?(Time) ? ts.strftime("%H:%M:%S") : ts&.split("T")&.last&.split(".")&.first
    from = e[:from] || e["from"]
    to = e[:to] || e["to"]
    summary = e[:summary] || e["summary"]

    line = "#{ts}  #{from} -> #{to}: #{summary}"
    line = line[0, 120] + "..." if line.length > 123
    puts line
  end
end

# === Main Entry Point ===

def run_env(args)
  cmd = PromptObjects::CLI::EnvCommand.new
  cmd.run(args)
end

def main
  if ARGV.empty?
    print_main_help
    exit 0
  end

  command = ARGV[0]
  args = ARGV[1..]

  case command
  when "env"
    run_env(args)
  when "repl"
    run_repl(args)
  when "serve"
    run_serve(args)
  when "message", "msg"
    run_message(args)
  when "events"
    run_events(args)
  when "help", "--help", "-h"
    print_main_help
  else
    # Legacy behavior: treat as repl with name argument
    run_repl(ARGV)
  end
end

main
